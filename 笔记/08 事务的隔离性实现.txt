每行数据对应多个版本，每次事务都会生成该行数据的一个版本。

事务启动时创建一致性视图，包含了一个当前所有活跃事务的数组，即开启却未提交的事务。
之后在该事务中观察到的每行数据，具体观察到该行数据的哪个版本，根据此数组来进行判定：
- 如果数据的row trans_id 低于低水位，说明事务启动前就提交的数据，可见
- 如果数据的row trans_id 高于高水位，说明是事务启动后新事务更新的数据，不可见
- 如果数据的row trans_id 落在高低水位之间，则如果在数组中，则表示由未提交的事务生成，不可见；
	如果不在数据中，说明由已提交的事务生成，可见。
	
这是根据具体的版本号来判断是否可见，在分析一个事务视图时，可见简单为：
1. 自己更新的自己可见
2. 版本未提交，不可见
	比如在视图创建前的更新未提交，则落在视图数组中，可不见；
	在视图创建后的更新未提交，又落在高水位，同样不可见
3. 版本已提交，但在视图创建后提交，不可见
	因为落在高水位或者视图数组中了
4. 版本已提交，并且在视图创建前提交，可见

更新逻辑
update 更新时要先读当前最新版本的行数据再更新，称为当前读。
select语句如果加锁也能是当前读：
	select k from t where id = 1 lock in share mode; (读锁， 共享锁)
	select k from t where id = 1 for update;         (写锁， 排他锁)
	
一致性读、当前读、行锁串起来；
两个未提交的事务要更新同一行，由于更新是先当前读再更新，
且需要获得锁，而另一个更新是写入改行数据的最新版本，且尚未未提交仍持有该
行锁，因此会锁等待。

总结：
普通查询语句是一致性读，一致性读会根据rowtrx_id和一致性视图确定数据版本的
可见性。
- 对于可重复读，查询只承认在事务启动前就已经提交完成的数据；
- 对于读提交，查询只承认在语句启动前就已经提交完成的数据；
而当前读，总是读取已经提交完成的最新版本。

